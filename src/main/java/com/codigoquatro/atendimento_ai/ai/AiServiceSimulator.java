package com.codigoquatro.atendimento_ai.ai;

import com.codigoquatro.atendimento_ai.model.Product;
import com.codigoquatro.atendimento_ai.service.SmComponentesScraperService;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.text.similarity.LevenshteinDistance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class AiServiceSimulator implements AiService {

    private static final Logger logger = LoggerFactory.getLogger(AiServiceSimulator.class);
    private static final double SIMILARITY_THRESHOLD = 0.70;
    private static final int MAX_LEVENSHTEIN_DISTANCE = 5;

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final LevenshteinDistance levenshteinDistance = LevenshteinDistance.getDefaultInstance();
    private HttpClient httpClient;
    private String apiKey;
    private String model;
    private List<KnowledgeEntry> knowledgeBase = List.of();

    // Cache inteligente para perguntas frequentes
    private final Map<String, CacheEntry> responseCache = new LinkedHashMap<>() {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, CacheEntry> eldest) {
            return size() > 100; // Mant√©m apenas 100 entradas no cache
        }
    };

    private final SmComponentesScraperService scraperService;

    // Palavras-chave para detec√ß√£o de inten√ß√£o
    private static final Set<String> PRODUCT_KEYWORDS = Set.of(
            "comprar", "produto", "componente", "conector", "cabo", "adaptador",
            "pre√ßo", "valor", "custo", "onde encontrar", "quero comprar"
    );

    private static final Set<String> SUPPORT_KEYWORDS = Set.of(
            "problema", "ajuda", "suporte", "d√∫vida", "como usar", "funcionamento",
            "defeito", "n√£o funciona", "garantia", "tutorial"
    );

    public AiServiceSimulator(
            @Value("${openrouter.api.key}") String apiKey,
            @Value("${openrouter.model:openai/gpt-3.5-turbo}") String model,
            SmComponentesScraperService scraperService) {
        this.apiKey = apiKey;
        this.model = model;
        this.scraperService = scraperService;
    }

    @PostConstruct
    public void init() {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .build();
        loadKnowledgeBase();
    }

    private void loadKnowledgeBase() {
        try {
            ClassPathResource resource = new ClassPathResource("knowledge_base.json");
            try (InputStream inputStream = resource.getInputStream()) {
                this.knowledgeBase = objectMapper.readValue(inputStream,
                        objectMapper.getTypeFactory().constructCollectionType(List.class, KnowledgeEntry.class));
                logger.info("Base de conhecimento carregada com sucesso. {} entradas.", knowledgeBase.size());
            }
        } catch (Exception e) {
            logger.error("Erro ao carregar a base de conhecimento. Continuando com base vazia.", e);
            this.knowledgeBase = List.of();
        }
    }

    @Override
    public String getAnswerForQuestion(String question) {
        if (question == null || question.trim().isEmpty()) {
            return "Ol√°! üòä Como posso te ajudar hoje na SM Componentes?";
        }

        String normalizedQuestion = normalizeQuestion(question);

        // Verifica cache primeiro
        CacheEntry cachedResponse = responseCache.get(normalizedQuestion);
        if (cachedResponse != null && !cachedResponse.isExpired()) {
            logger.info("Resposta recuperada do cache para: {}", normalizedQuestion);
            return cachedResponse.getResponse();
        }

        try {
            // 1. Detectar inten√ß√£o da pergunta
            QuestionIntent intent = detectIntent(question);

            // 2. Busca na base de conhecimento est√°tica
            List<KnowledgeEntry> relevantEntries = findRelevantEntries(normalizedQuestion);

            // 3. Busca din√¢mica de produtos (apenas se for inten√ß√£o de compra/produto)
            List<Product> relevantProducts = Collections.emptyList();
            if (intent == QuestionIntent.PRODUCT_INQUIRY) {
                relevantProducts = scraperService.searchProducts(question);
            }

            // 4. Monta contexto combinado baseado na inten√ß√£o
            String context = buildContext(intent, relevantEntries, relevantProducts, question);

            // 5. Se encontrou resposta exata na base de conhecimento, usa ela
            if (!relevantEntries.isEmpty() && hasExactMatch(relevantEntries, normalizedQuestion)) {
                String exactAnswer = relevantEntries.get(0).getAnswer();
                cacheResponse(normalizedQuestion, exactAnswer);
                return exactAnswer;
            }

            // 6. Monta prompt otimizado baseado na inten√ß√£o
            String prompt = buildPrompt(intent, question, context);

            // 7. Chama OpenRouter
            String aiResponse = callOpenRouter(prompt);

            // Processa links para garantir que sejam clic√°veis
            String processedResponse = ensureClickableLinks(aiResponse);

            // Cache da resposta
            cacheResponse(normalizedQuestion, processedResponse);

            return processedResponse;

        } catch (Exception e) {
            logger.error("Erro inesperado ao processar pergunta: '{}'", question, e);
            return getFallbackResponse(question);
        }
    }

    private String normalizeQuestion(String question) {
        return question.toLowerCase()
                .replaceAll("[^a-z0-9√°√©√≠√≥√∫√¢√™√Æ√¥√ª√£√µ√ß\\s]", "")
                .replaceAll("\\s+", " ")
                .trim();
    }

    private QuestionIntent detectIntent(String question) {
        String lowerQuestion = question.toLowerCase();

        boolean hasProductKeywords = PRODUCT_KEYWORDS.stream()
                .anyMatch(lowerQuestion::contains);

        boolean hasSupportKeywords = SUPPORT_KEYWORDS.stream()
                .anyMatch(lowerQuestion::contains);

        if (hasProductKeywords) {
            return QuestionIntent.PRODUCT_INQUIRY;
        } else if (hasSupportKeywords) {
            return QuestionIntent.SUPPORT_REQUEST;
        } else {
            return QuestionIntent.GENERAL_INQUIRY;
        }
    }

    private List<KnowledgeEntry> findRelevantEntries(String userQuestion) {
        if (knowledgeBase.isEmpty()) return List.of();

        return knowledgeBase.stream()
                .map(entry -> {
                    double similarityScore = calculateSimilarity(userQuestion, entry.getQuestion());
                    return Map.entry(entry, similarityScore);
                })
                .filter(e -> e.getValue() >= SIMILARITY_THRESHOLD)
                .sorted(Map.Entry.<KnowledgeEntry, Double>comparingByValue().reversed())
                .limit(3)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
    }

    private double calculateSimilarity(String question1, String question2) {
        String normalized1 = normalizeQuestion(question1);
        String normalized2 = normalizeQuestion(question2);

        // Usa Levenshtein para similaridade
        int maxLength = Math.max(normalized1.length(), normalized2.length());
        if (maxLength == 0) return 1.0;

        int distance = levenshteinDistance.apply(normalized1, normalized2);
        double similarity = 1.0 - ((double) distance / maxLength);

        return similarity;
    }

    private boolean hasExactMatch(List<KnowledgeEntry> entries, String userQuestion) {
        return entries.stream()
                .anyMatch(entry -> {
                    String normalizedEntryQuestion = normalizeQuestion(entry.getQuestion());
                    int distance = levenshteinDistance.apply(userQuestion, normalizedEntryQuestion);
                    return distance <= MAX_LEVENSHTEIN_DISTANCE;
                });
    }

    private String buildContext(QuestionIntent intent, List<KnowledgeEntry> entries,
                                List<Product> products, String originalQuestion) {
        StringBuilder sb = new StringBuilder();

        // Informa√ß√µes institucionais (para todos os tipos de inten√ß√£o)
        if (!entries.isEmpty()) {
            sb.append("üìö **Informa√ß√µes institucionais relevantes:**\n");
            for (KnowledgeEntry entry : entries) {
                sb.append("‚Ä¢ ").append(entry.getAnswer()).append("\n");
            }
            sb.append("\n");
        }

        // Produtos (apenas para inten√ß√£o de produto)
        if (intent == QuestionIntent.PRODUCT_INQUIRY) {
            if (!products.isEmpty()) {
                sb.append("üõí **Produtos encontrados na SM Componentes:**\n");
                for (Product p : products) {
                    sb.append(String.format(
                            "‚Ä¢ **%s** (Categoria: %s)\n  üîó <a href=\"%s\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">Ver produto</a>\n\n",
                            p.getName(),
                            p.getCategory(),
                            p.getProductUrl()
                    ));
                }
            } else {
                sb.append("üîç **Sugest√£o de categorias para sua busca:**\n");
                sb.append("‚Ä¢ <a href=\"https://smcomponentes.com.br/loja/categoria-conectores-variados\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">Conectores Variados</a>\n");
                sb.append("‚Ä¢ <a href=\"https://smcomponentes.com.br/loja/categoria-potenciometros\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">Potenci√¥metros</a>\n");
                sb.append("‚Ä¢ <a href=\"https://smcomponentes.com.br/loja/categoria-audio-e-video\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">√Åudio e V√≠deo</a>\n");
                sb.append("‚Ä¢ <a href=\"https://smcomponentes.com.br/loja/categoria-acessorios\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">Acess√≥rios</a>\n");
                sb.append("‚Ä¢ <a href=\"https://smcomponentes.com.br/loja/categoria-cabos-de-energia\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">Cabos de Energia</a>\n");
            }
        }

        // Informa√ß√µes de suporte (apenas para inten√ß√£o de suporte)
        if (intent == QuestionIntent.SUPPORT_REQUEST) {
            sb.append("üîß **Informa√ß√µes de suporte t√©cnico:**\n");
            sb.append("‚Ä¢ Hor√°rio de atendimento: Segunda a Sexta, 8h √†s 18h\n");
            sb.append("‚Ä¢ Email de suporte: <a href=\"mailto:suporte@smcomponentes.com.br\" style=\"color: #007bff; text-decoration: none;\">suporte@smcomponentes.com.br</a>\n");
            sb.append("‚Ä¢ WhatsApp: <a href=\"https://wa.me/5511999999999\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">(11) 99999-9999</a>\n");
        }

        return sb.toString().trim();
    }

    private String buildPrompt(QuestionIntent intent, String question, String context) {
        String role = getRoleByIntent(intent);

        return """
            %s

            Contexto dispon√≠vel:
            %s

            Pergunta do cliente:
            "%s"

            Regras importantes:
            - Seja direto e √∫til
            - Use formata√ß√£o Markdown quando apropriado
            - Se n√£o souber a resposta exata, seja honesto
            - Mantenha o tom profissional mas amig√°vel
            - Use emojis com modera√ß√£o (m√°ximo 2-3 por resposta)
            - SEMPRE use links HTML para URLs: <a href="URL" target="_blank">Texto</a>
            - Para emails use: <a href="mailto:email@exemplo.com">email@exemplo.com</a>
            - Para WhatsApp use: <a href="https://wa.me/5511999999999" target="_blank">(11) 99999-9999</a>

            Resposta (em portugu√™s do Brasil):
            """.formatted(role, context, question);
    }

    private String getRoleByIntent(QuestionIntent intent) {
        switch (intent) {
            case PRODUCT_INQUIRY:
                return "Voc√™ √© um vendedor especializado da SM Componentes, loja de componentes eletr√¥nicos. Sua miss√£o √© ajudar clientes a encontrar produtos e fornecer informa√ß√µes t√©cnicas precisas. SEMPRE inclua links clic√°veis para produtos e categorias usando HTML <a> tags.";
            case SUPPORT_REQUEST:
                return "Voc√™ √© um t√©cnico de suporte da SM Componentes. Sua miss√£o √© resolver problemas t√©cnicos, fornecer orienta√ß√µes e direcionar para o canal apropriado quando necess√°rio. SEMPRE inclua links de contato clic√°veis usando HTML <a> tags.";
            default:
                return "Voc√™ √© um atendente da SM Componentes. Sua miss√£o √© responder d√∫vidas gerais sobre a empresa, produtos e servi√ßos de forma clara e √∫til. SEMPRE use links HTML clic√°veis quando mencionar URLs.";
        }
    }

    private String callOpenRouter(String prompt) {
        String url = "https://openrouter.ai/api/v1/chat/completions";
        String referer = "https://smcomponentes.com.br";

        try {
            Map<String, Object> requestBodyMap = new HashMap<>();
            requestBodyMap.put("model", model);

            List<Map<String, String>> messages = new ArrayList<>();
            Map<String, String> message = new HashMap<>();
            message.put("role", "user");
            message.put("content", prompt);
            messages.add(message);

            requestBodyMap.put("messages", messages);
            requestBodyMap.put("temperature", 0.6);
            requestBodyMap.put("max_tokens", 800);

            String requestBody = objectMapper.writeValueAsString(requestBodyMap);

            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .header("Authorization", "Bearer " + apiKey)
                    .header("Content-Type", "application/json")
                    .header("HTTP-Referer", referer)
                    .header("X-Title", "SM Componentes - Atendente AI")
                    .timeout(Duration.ofSeconds(30))
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                logger.error("Erro OpenRouter ({}): {}", response.statusCode(), response.body());
                throw new RuntimeException("Erro na API de IA: " + response.statusCode());
            }

            JsonNode json = objectMapper.readTree(response.body());
            JsonNode contentNode = json.path("choices").get(0).path("message").path("content");
            if (contentNode.isMissingNode() || contentNode.isNull()) {
                throw new RuntimeException("Resposta da IA sem conte√∫do");
            }

            return contentNode.asText().trim();

        } catch (IOException | InterruptedException e) {
            logger.error("Falha na chamada √† OpenRouter", e);
            Thread.currentThread().interrupt();
            throw new RuntimeException("Falha de comunica√ß√£o com o servi√ßo de IA", e);
        }
    }

    private String ensureClickableLinks(String response) {
        // Converte markdown [texto](url) para HTML <a>
        String withHtmlLinks = response.replaceAll(
            "\\[([^\\]]+)\\]\\(([^)]+)\\)", 
            "<a href=\"$2\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">$1</a>"
        );
        
        // Garante que URLs soltas tamb√©m sejam links
        String withBareUrls = withHtmlLinks.replaceAll(
            "(?<!href=\")(https?://[^\\s<>\"]+)(?!\"[^>]*>)(?![^<]*</a>)", 
            "<a href=\"$1\" target=\"_blank\" style=\"color: #007bff; text-decoration: none;\">$1</a>"
        );
        
        return withBareUrls;
    }

    private void cacheResponse(String question, String response) {
        responseCache.put(question, new CacheEntry(response));
    }

    private String getFallbackResponse(String originalQuestion) {
        return """
            Ol√°! üòä 
            
            No momento, estou com dificuldades t√©cnicas, mas posso te ajudar de outras formas:

            üîç **Para encontrar produtos:** 
            Visite nossas categorias principais em <a href="https://smcomponentes.com.br" target="_blank" style="color: #007bff; text-decoration: none;">smcomponentes.com.br</a>

            üìû **Para suporte t√©cnico:**
            Entre em contato pelo <a href="https://wa.me/5511999999999" target="_blank" style="color: #007bff; text-decoration: none;">WhatsApp (11) 99999-9999</a>

            üìß **Para outras d√∫vidas:**
            Envie um email para <a href="mailto:contato@smcomponentes.com.br" style="color: #007bff; text-decoration: none;">contato@smcomponentes.com.br</a>

            Enquanto isso, voc√™ pode reformular sua pergunta? Vou tentar novamente! üîß
            """;
    }

    // Classes internas para organiza√ß√£o
    private enum QuestionIntent {
        PRODUCT_INQUIRY, SUPPORT_REQUEST, GENERAL_INQUIRY
    }

    private static class CacheEntry {
        private final String response;
        private final long timestamp;
        private static final long CACHE_TTL = 30 * 60 * 1000; // 30 minutos

        CacheEntry(String response) {
            this.response = response;
            this.timestamp = System.currentTimeMillis();
        }

        public String getResponse() {
            return response;
        }

        public boolean isExpired() {
            return (System.currentTimeMillis() - timestamp) > CACHE_TTL;
        }
    }
}